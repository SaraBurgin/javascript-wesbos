{"version":3,"sources":["utils.js","sound.js"],"names":["hslToRgb","h","s","l","r","g","b","hue2rgb","p","q","t","Math","round","WIDTH","HEIGHT","canvas","document","querySelector","ctx","getContext","width","height","analyzer","bufferLength","handleError","err","console","log","getAudio","stream","navigator","mediaDevices","getUserMedia","audio","catch","audioCtx","AudioContext","createAnalyser","source","createMediaStreamSource","connect","fftSize","frequencyBinCount","timeData","Uint8Array","frequencyData","drawTimeData","drawFrequency","getByteTimeDomainData","clearRect","lineWidth","strokeStyle","beginPath","sliceWidth","x","forEach","data","i","v","y","moveTo","lineTo","stroke","requestAnimationFrame","getByteFrequencyData","barWidth","amount","percent","barHeight","fillStyle","fillRect"],"mappings":"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","file":"sound.66e01127.js","sourceRoot":"..","sourcesContent":["export function hslToRgb(h, s, l) {\n  let r;\n  let g;\n  let b;\n\n  if (s == 0) {\n    r = g = b = l; // achromatic\n  } else {\n    const hue2rgb = function hue2rgb(p, q, t) {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    };\n\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n\n  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n","import { hslToRgb } from './utils.js';\n\nconst WIDTH = 1500;\nconst HEIGHT = 1500;\nconst canvas = document.querySelector('canvas');\nconst ctx = canvas.getContext('2d');\ncanvas.width = WIDTH;\ncanvas.height = HEIGHT;\nlet analyzer;\nlet bufferLength;\n\n// Then we draw the frequency bars\n// Then the time data\n\nfunction handleError(err) {\n        console.log('You must give access to your mic in order to proceed');\n}\n// First we need to get the audio\n// This is why we use a server, because we need to get access to the users microphone. It needs to be over a secure origin -> something that is https or lcoalhost.\nasync function getAudio() {\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true }).catch(handleError);\n        const audioCtx = new AudioContext();\n        analyzer = audioCtx.createAnalyser();\n        const source = audioCtx.createMediaStreamSource(stream);\n        source.connect(analyzer);\n        // how much data should we collect\n        analyzer.fftSize = 2 ** 10;\n        // pull the data off the audio\n        // how many pieces of data are there?!?\n        bufferLength = analyzer.frequencyBinCount;\n        const timeData = new Uint8Array(bufferLength);\n        const frequencyData = new Uint8Array(bufferLength);\n        drawTimeData(timeData);\n        drawFrequency(frequencyData);\n}\n\nfunction drawTimeData(timeData) {\n        // inject the time data into our timeData array. This gives us the visualization over time.\n        analyzer.getByteTimeDomainData(timeData);\n        // now that we have the data, lets turn it into something visual\n        // 1. clear the canvas\n        ctx.clearRect(0, 0, WIDTH, HEIGHT);\n        // 2. set-up some canvas drawing\n        ctx.lineWidth = 10;\n        ctx.strokeStyle = '#ffc600';\n        ctx.beginPath();\n        const sliceWidth = WIDTH / bufferLength;\n        let x = 0;\n        timeData.forEach((data, i) => {\n                const v = data / 128;\n                const y = (v * HEIGHT) / 2;\n                // Draw our lines\n                if (i === 0) {\n                        ctx.moveTo(x, y);\n                } else {\n                        ctx.lineTo(x, y);\n                }\n                x += sliceWidth;\n        });\n        // paints it to our canvas\n        ctx.stroke();\n        // call itself as soon as possible\n        requestAnimationFrame(() => drawTimeData(timeData));\n}\n\nfunction drawFrequency(frequencyData) {\n        // get the frequency data in to our frequencyData array\n        analyzer.getByteFrequencyData(frequencyData);\n        // figure out the bar width based on how much data and width we have. We multiply it by 2.5 so we only get the lower end.\n        const barWidth = (WIDTH / bufferLength) * 2.5;\n        const x = 0;\n        frequencyData.forEach(amount => {\n                // frequency comes in from 0 to 255\n                const percent = amount / 255;\n                const [h, s, l] = [360 / (percent * 360) - 0.5, 0.5, 0.5];\n                const barHeight = (HEIGHT * percent) / 2;\n                // convent the colour to HSL TODO\n                const [r, g, b] = hslToRgb(h, s, l);\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n                ctx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight);\n                x += barWidth + 2;\n        });\n\n        requestAnimationFrame(() => drawFrequency(frequencyData));\n}\n\ngetAudio();\n"]}